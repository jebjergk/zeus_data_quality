name: Auto PR & Squash Merge to dev_bs (no marketplace deps)

on:
  push:
    branches-ignore:
      - main
      - dev_bs
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  checks: read
  statuses: read

jobs:
  pr-and-merge:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Ensure PR exists -> dev_bs and wait/merge
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const head = context.ref.replace('refs/heads/', '');
            const base = 'dev_bs';
            if (head === base || head === 'main') {
              core.notice(`Skipping branch ${head}`); return;
            }

            // Find or create PR head->base
            const list = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open', head: `${owner}:${head}`, base });
            let pr = list[0];
            if (!pr) {
              const created = await github.rest.pulls.create({
                owner, repo, head, base,
                title: `Merge ${head} into ${base}`,
                body: 'Auto-created by CI.'
              });
              pr = created.data;
            } else {
              core.notice(`Using existing PR #${pr.number}`);
            }

            // Helper: wait for green checks/status
            async function waitForGreen(sha, timeoutSec = 1800, pollMs = 10000) {
              const start = Date.now();
              while (true) {
                // Combined status (legacy)
                const { data: status } = await github.rest.repos.getCombinedStatusForRef({ owner, repo, ref: sha });
                const state = status.state; // success, failure, pending
                // Checks API (new)
                const checks = await github.rest.checks.listForRef({ owner, repo, ref: sha });
                const badCheck = checks.data.check_runs.find(cr => ['failure','cancelled','timed_out','action_required'].includes((cr.conclusion||'').toLowerCase()));
                const pendingCheck = checks.data.check_runs.find(cr => !cr.conclusion && ['in_progress','queued','waiting','requested'].includes((cr.status||'').toLowerCase()));

                if (badCheck) {
                  core.setFailed(`A check failed: ${badCheck.name}`);
                  return false;
                }

                // If there are check runs, require them all to be successful/neutral/skipped
                const hasChecks = checks.data.total_count > 0;
                const allGood = !hasChecks || (checks.data.check_runs.every(cr => ['success','neutral','skipped'].includes((cr.conclusion||'').toLowerCase())));
                const statusesGood = (state === 'success' || (!hasChecks && state !== 'failure'));

                if (allGood && statusesGood) return true;

                if ((Date.now() - start) / 1000 > timeoutSec) {
                  core.setFailed('Timeout waiting for checks to pass.');
                  return false;
                }
                await new Promise(r => setTimeout(r, pollMs));
              }
            }

            // Wait for head SHA checks
            const sha = pr.head.sha;
            const ok = await waitForGreen(sha);
            if (!ok) return;

            // Squash-merge
            await github.rest.pulls.merge({
              owner, repo,
              pull_number: pr.number,
              merge_method: 'squash'
            });

            // Delete source branch
            try {
              await github.rest.git.deleteRef({ owner, repo, ref: `heads/${head}` });
            } catch (e) {
              core.warning(`Could not delete branch ${head}: ${e.message}`);
            }
